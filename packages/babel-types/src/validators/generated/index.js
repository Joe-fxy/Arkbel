/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'make build'
 */
/* eslint-disable no-fallthrough */
import shallowEqual from "../../utils/shallowEqual.ts";
import deprecationWarning from "../../utils/deprecationWarning.ts";
export function isArrayExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArrayExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isAssignmentExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "AssignmentExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBinaryExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BinaryExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isInterpreterDirective(node, opts) {
    if (!node)
        return false;
    if (node.type !== "InterpreterDirective")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDirective(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Directive")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDirectiveLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DirectiveLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBlockStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BlockStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBreakStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BreakStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isCallExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "CallExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isArkTSCallExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArkTSCallExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isCatchClause(node, opts) {
    if (!node)
        return false;
    if (node.type !== "CatchClause")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isConditionalExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ConditionalExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isContinueStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ContinueStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDebuggerStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DebuggerStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDoWhileStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DoWhileStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEmptyStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EmptyStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExpressionStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExpressionStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isFile(node, opts) {
    if (!node)
        return false;
    if (node.type !== "File")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isForInStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ForInStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isForStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ForStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isFunctionDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "FunctionDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isFunctionExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "FunctionExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isIdentifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Identifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isIfStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "IfStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isLabeledStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "LabeledStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isStringLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "StringLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNumericLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NumericLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNullLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NullLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBooleanLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BooleanLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isRegExpLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "RegExpLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isLogicalExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "LogicalExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isMemberExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "MemberExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNewExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NewExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isProgram(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Program")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectMethod(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectMethod")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isRestElement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "RestElement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isReturnStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ReturnStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isSequenceExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "SequenceExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isParenthesizedExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ParenthesizedExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isSwitchCase(node, opts) {
    if (!node)
        return false;
    if (node.type !== "SwitchCase")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isSwitchStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "SwitchStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isThisExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ThisExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isThrowStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ThrowStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTryStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TryStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isUnaryExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "UnaryExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isUpdateExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "UpdateExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isVariableDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "VariableDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isVariableDeclarator(node, opts) {
    if (!node)
        return false;
    if (node.type !== "VariableDeclarator")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isWhileStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "WhileStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isWithStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "WithStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isAssignmentPattern(node, opts) {
    if (!node)
        return false;
    if (node.type !== "AssignmentPattern")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isArrayPattern(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArrayPattern")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isArrowFunctionExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArrowFunctionExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassBody(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassBody")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isArkTSStructDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArkTSStructDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExportAllDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExportAllDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExportDefaultDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExportDefaultDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExportNamedDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExportNamedDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExportSpecifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExportSpecifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isForOfStatement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ForOfStatement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImportDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ImportDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImportDefaultSpecifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ImportDefaultSpecifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImportNamespaceSpecifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ImportNamespaceSpecifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImportSpecifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ImportSpecifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImportExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ImportExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isMetaProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "MetaProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassMethod(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassMethod")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectPattern(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectPattern")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isSpreadElement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "SpreadElement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isSuper(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Super")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTaggedTemplateExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TaggedTemplateExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTemplateElement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TemplateElement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTemplateLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TemplateLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isYieldExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "YieldExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isAwaitExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "AwaitExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImport(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Import")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBigIntLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BigIntLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExportNamespaceSpecifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExportNamespaceSpecifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isOptionalMemberExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "OptionalMemberExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isOptionalCallExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "OptionalCallExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassAccessorProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassAccessorProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassPrivateProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassPrivateProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassPrivateMethod(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassPrivateMethod")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isPrivateName(node, opts) {
    if (!node)
        return false;
    if (node.type !== "PrivateName")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isStaticBlock(node, opts) {
    if (!node)
        return false;
    if (node.type !== "StaticBlock")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isAnyTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "AnyTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isArrayTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArrayTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBooleanTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BooleanTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BooleanLiteralTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNullLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NullLiteralTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isClassImplements(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ClassImplements")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareClass(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareClass")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareFunction(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareFunction")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareInterface(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareInterface")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareModule(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareModule")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareModuleExports(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareModuleExports")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareTypeAlias(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareTypeAlias")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareOpaqueType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareOpaqueType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareVariable(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareVariable")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareExportDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareExportDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclareExportAllDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclareExportAllDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDeclaredPredicate(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DeclaredPredicate")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExistsTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExistsTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isFunctionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "FunctionTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isFunctionTypeParam(node, opts) {
    if (!node)
        return false;
    if (node.type !== "FunctionTypeParam")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isGenericTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "GenericTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isInferredPredicate(node, opts) {
    if (!node)
        return false;
    if (node.type !== "InferredPredicate")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isInterfaceExtends(node, opts) {
    if (!node)
        return false;
    if (node.type !== "InterfaceExtends")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isInterfaceDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "InterfaceDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isInterfaceTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "InterfaceTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isIntersectionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "IntersectionTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isMixedTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "MixedTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEmptyTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EmptyTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNullableTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NullableTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NumberLiteralTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNumberTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "NumberTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectTypeInternalSlot(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectTypeInternalSlot")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectTypeCallProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectTypeCallProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectTypeIndexer(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectTypeIndexer")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectTypeProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectTypeProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isObjectTypeSpreadProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ObjectTypeSpreadProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isOpaqueType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "OpaqueType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isQualifiedTypeIdentifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "QualifiedTypeIdentifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isStringLiteralTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "StringLiteralTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isStringTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "StringTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isSymbolTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "SymbolTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isThisTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ThisTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTupleTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TupleTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeofTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeofTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeAlias(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeAlias")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeCastExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeCastExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeParameter(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeParameter")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeParameterDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeParameterDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTypeParameterInstantiation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TypeParameterInstantiation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isUnionTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "UnionTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isVariance(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Variance")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isVoidTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "VoidTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumBooleanBody(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumBooleanBody")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumNumberBody(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumNumberBody")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumStringBody(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumStringBody")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumSymbolBody(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumSymbolBody")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumBooleanMember(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumBooleanMember")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumNumberMember(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumNumberMember")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumStringMember(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumStringMember")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isEnumDefaultedMember(node, opts) {
    if (!node)
        return false;
    if (node.type !== "EnumDefaultedMember")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isIndexedAccessType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "IndexedAccessType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isOptionalIndexedAccessType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "OptionalIndexedAccessType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXAttribute(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXAttribute")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXClosingElement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXClosingElement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXElement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXElement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXEmptyExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXEmptyExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXExpressionContainer(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXExpressionContainer")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXSpreadChild(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXSpreadChild")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXIdentifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXIdentifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXMemberExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXMemberExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXNamespacedName(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXNamespacedName")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXOpeningElement(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXOpeningElement")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXSpreadAttribute(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXSpreadAttribute")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXText(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXText")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXFragment(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXFragment")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXOpeningFragment(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXOpeningFragment")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isJSXClosingFragment(node, opts) {
    if (!node)
        return false;
    if (node.type !== "JSXClosingFragment")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isNoop(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Noop")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isPlaceholder(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Placeholder")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isV8IntrinsicIdentifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "V8IntrinsicIdentifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isArgumentPlaceholder(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ArgumentPlaceholder")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isBindExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "BindExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isImportAttribute(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ImportAttribute")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDecorator(node, opts) {
    if (!node)
        return false;
    if (node.type !== "Decorator")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDoExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DoExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isExportDefaultSpecifier(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ExportDefaultSpecifier")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isRecordExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "RecordExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTupleExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TupleExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isDecimalLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "DecimalLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isModuleExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "ModuleExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTopicReference(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TopicReference")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isPipelineTopicExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "PipelineTopicExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isPipelineBareFunction(node, opts) {
    if (!node)
        return false;
    if (node.type !== "PipelineBareFunction")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isPipelinePrimaryTopicReference(node, opts) {
    if (!node)
        return false;
    if (node.type !== "PipelinePrimaryTopicReference")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSParameterProperty(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSParameterProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSDeclareFunction(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSDeclareFunction")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSDeclareMethod(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSDeclareMethod")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSQualifiedName(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSQualifiedName")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSCallSignatureDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSCallSignatureDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSConstructSignatureDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSConstructSignatureDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSPropertySignature(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSPropertySignature")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSMethodSignature(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSMethodSignature")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSIndexSignature(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSIndexSignature")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSAnyKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSAnyKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSBooleanKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSBooleanKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSBigIntKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSBigIntKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSIntrinsicKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSIntrinsicKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSNeverKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSNeverKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSNullKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSNullKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSNumberKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSNumberKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSObjectKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSObjectKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSStringKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSStringKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSSymbolKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSSymbolKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSUndefinedKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSUndefinedKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSUnknownKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSUnknownKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSVoidKeyword(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSVoidKeyword")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSThisType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSThisType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSFunctionType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSFunctionType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSConstructorType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSConstructorType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeReference(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeReference")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypePredicate(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypePredicate")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeQuery(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeQuery")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeLiteral(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSArrayType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSArrayType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTupleType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTupleType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSOptionalType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSOptionalType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSRestType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSRestType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSNamedTupleMember(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSNamedTupleMember")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSUnionType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSUnionType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSIntersectionType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSIntersectionType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSConditionalType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSConditionalType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSInferType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSInferType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSParenthesizedType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSParenthesizedType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeOperator(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeOperator")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSIndexedAccessType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSIndexedAccessType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSMappedType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSMappedType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSLiteralType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSLiteralType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSExpressionWithTypeArguments(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSExpressionWithTypeArguments")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSInterfaceDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSInterfaceDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSInterfaceBody(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSInterfaceBody")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeAliasDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeAliasDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSInstantiationExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSInstantiationExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSAsExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSAsExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSSatisfiesExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSSatisfiesExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeAssertion(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeAssertion")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSEnumDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSEnumDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSEnumMember(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSEnumMember")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSModuleDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSModuleDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSModuleBlock(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSModuleBlock")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSImportType(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSImportType")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSImportEqualsDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSImportEqualsDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSExternalModuleReference(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSExternalModuleReference")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSNonNullExpression(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSNonNullExpression")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSExportAssignment(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSExportAssignment")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSNamespaceExportDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSNamespaceExportDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeAnnotation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeAnnotation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeParameterInstantiation(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeParameterInstantiation")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeParameterDeclaration(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeParameterDeclaration")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeParameter(node, opts) {
    if (!node)
        return false;
    if (node.type !== "TSTypeParameter")
        return false;
    return opts == null || shallowEqual(node, opts);
}
export function isStandardized(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "ArkTSCallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ArkTSStructDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
            break;
        case "Placeholder":
            switch (node.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isExpression(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ArkTSCallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
            break;
        case "Placeholder":
            switch (node.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isBinary(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BinaryExpression":
        case "LogicalExpression":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isScopable(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ArkTSStructDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
            break;
        case "Placeholder":
            if (node.expectedNode === "BlockStatement")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isBlockParent(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
            break;
        case "Placeholder":
            if (node.expectedNode === "BlockStatement")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isBlock(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
            break;
        case "Placeholder":
            if (node.expectedNode === "BlockStatement")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isStatement(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ArkTSStructDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
            break;
        case "Placeholder":
            switch (node.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isTerminatorless(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isCompletionStatement(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isConditional(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ConditionalExpression":
        case "IfStatement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isLoop(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isWhile(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "DoWhileStatement":
        case "WhileStatement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isExpressionWrapper(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFor(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isForXStatement(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ForInStatement":
        case "ForOfStatement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFunction(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFunctionParent(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isPureish(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
            break;
        case "Placeholder":
            if (node.expectedNode === "StringLiteral")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isDeclaration(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ArkTSStructDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
            break;
        case "Placeholder":
            if (node.expectedNode === "Declaration")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isPatternLike(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
            break;
        case "Placeholder":
            switch (node.expectedNode) {
                case "Pattern":
                case "Identifier":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isLVal(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
            break;
        case "Placeholder":
            switch (node.expectedNode) {
                case "Pattern":
                case "Identifier":
                    break;
                default:
                    return false;
            }
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isTSEntityName(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "Identifier":
        case "TSQualifiedName":
            break;
        case "Placeholder":
            if (node.expectedNode === "Identifier")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isLiteral(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
            break;
        case "Placeholder":
            if (node.expectedNode === "StringLiteral")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isImmutable(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
            break;
        case "Placeholder":
            if (node.expectedNode === "StringLiteral")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isUserWhitespacable(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isMethod(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isObjectMember(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ObjectMethod":
        case "ObjectProperty":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isProperty(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isUnaryLike(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "UnaryExpression":
        case "SpreadElement":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isPattern(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
            break;
        case "Placeholder":
            if (node.expectedNode === "Pattern")
                break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isClass(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ClassExpression":
        case "ClassDeclaration":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isImportOrExportDeclaration(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isExportDeclaration(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isModuleSpecifier(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isAccessor(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ClassAccessorProperty":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isPrivate(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFlow(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFlowType(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFlowBaseAnnotation(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFlowDeclaration(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isFlowPredicate(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isEnumBody(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isEnumMember(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isJSX(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isMiscellaneous(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isTypeScript(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isTSTypeElement(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isTSType(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
export function isTSBaseType(node, opts) {
    if (!node)
        return false;
    switch (node.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSLiteralType":
            break;
        default:
            return false;
    }
    return opts == null || shallowEqual(node, opts);
}
/**
 * @deprecated Use `isNumericLiteral`
 */
export function isNumberLiteral(node, opts) {
    deprecationWarning("isNumberLiteral", "isNumericLiteral");
    if (!node)
        return false;
    if (node.type !== "NumberLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
/**
 * @deprecated Use `isRegExpLiteral`
 */
export function isRegexLiteral(node, opts) {
    deprecationWarning("isRegexLiteral", "isRegExpLiteral");
    if (!node)
        return false;
    if (node.type !== "RegexLiteral")
        return false;
    return opts == null || shallowEqual(node, opts);
}
/**
 * @deprecated Use `isRestElement`
 */
export function isRestProperty(node, opts) {
    deprecationWarning("isRestProperty", "isRestElement");
    if (!node)
        return false;
    if (node.type !== "RestProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
/**
 * @deprecated Use `isSpreadElement`
 */
export function isSpreadProperty(node, opts) {
    deprecationWarning("isSpreadProperty", "isSpreadElement");
    if (!node)
        return false;
    if (node.type !== "SpreadProperty")
        return false;
    return opts == null || shallowEqual(node, opts);
}
/**
 * @deprecated Use `isImportOrExportDeclaration`
 */
export function isModuleDeclaration(node, opts) {
    deprecationWarning("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node, opts);
}
